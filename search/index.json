[{"content":" 题目链接：3. 无重复字符的最长子串 知识回顾 双指针常用套路 关键观察 右窗口动，直到出现重复 左窗口动，直到没有重复 算法步骤 初始化： left = 0：滑动窗口左边界 cur = set()：记录当前窗口中出现的字符（用集合而非元组，支持 O (1) 查重与删除） output = 0：记录最长无重复子串长度 遍历字符串（right 从 0 到 n-1）： 若 s[right] 已在 cur 中： 循环从 cur 中移除 s[left]，并右移 left，直到 s[right] 不再重复 将 s[right] 加入 cur 更新 output = max(output, right - left + 1) 返回 output 复杂度分析 时间复杂度：$O(n)$ 每个字符最多被 right 访问一次，被 left 删除一次，总体线性 空间复杂度：$O(min⁡(m,n))$ 其中 $n$ 是字符串长度，$m$ 是字符集大小（如 ASCII 为 128） 最坏情况下，cur 存储所有不重复字符（如全为不同字符） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: # 右窗口动，直到出现重复 # 左窗口动，直到没有重复 output = 0 left = 0 cur = set() for right, s_ in enumerate(s): while s_ in cur: cur.remove(s[left]) left += 1 cur.add(s_) output = max(output, right - left + 1) return output 优化，可以直接使用哈希表记录字符的索引，left 可以直接跳转，从而避免 while 循环 ","date":"2025-12-20T00:00:00Z","permalink":"https://example.com/p/3-longest-substring-without-repeating-characters/","title":"003. 无重复字符的最长子串"},{"content":" 题目链接：438. 找到字符串中所有字母异位词 知识回顾 双指针常用套路 关键观察 只需维护一个长度为 len(p) 的滑动窗口，判断窗口内字符的频次是否与 p 完全一致 算法步骤 初始化：统计 p 字符出现次数 遍历 s 将当前字符加入窗口，并更新其频次。 当窗口长度达到 len(p) 时，比较窗口内字符频次与 p 是否一致。 若一致，将当前窗口起始索引加入结果列表。 滑动窗口：移除最左侧字符（即窗口左边界右移）。 复杂度分析 时间复杂度：$O(26*n) = O(n)$ $n$ 为 s 长度，26 为字符种类 空间复杂度：$O(1)$ 主要用于存储 p 和窗口的字符频次（实际各自最多 26 个） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution: def findAnagrams(self, s: str, p: str) -\u0026gt; List[int]: output = [] n = len(p) p_dict = defaultdict(int) for i in p: p_dict[i] += 1 # 维护一个字典，记录窗口中字符出现的次数 windows = defaultdict(int) for i , c in enumerate(s): windows[c] += 1 if i \u0026lt; n - 1: # 直到长度符合 continue for k in p_dict.keys(): if windows[k] != p_dict[k]: break else: output.append(i - n + 1) windows[s[i - n + 1]] -= 1 return output ","date":"2025-12-20T00:00:00Z","permalink":"https://example.com/p/438-find-all-anagrams-in-a-string/","title":"438. 找到字符串中所有字母异位词"},{"content":" 题目链接：11. 盛最多水的容器 知识回顾： 双指针常用套路 关键观察 需要维护容器左右位置，很明显，是双指针 由于维护的是一个左右区域，所以双指针从头尾开始 面积受限于较短边；若移动较长边，宽度减小且高度不会增加，面积必然不会变大。只有移动较短边，才可能找到更高的边界，从而获得更大面积。 复杂度分析 时间复杂度：$O(n)$ 每个元素至多被访问一次，左右指针向中间收敛 空间复杂度：$O(1)$ 仅使用常数级额外空间 1 2 3 4 5 6 7 8 9 10 11 12 class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: left = 0 right = len(height) - 1 output = 0 while left \u0026lt; right: output = max(output, min(height[left], height[right]) * (right - left)) if height[left] \u0026lt; height[right]: left += 1 else: right -= 1 return output ","date":"2025-12-19T00:00:00Z","permalink":"https://example.com/p/blog-post-slug/","title":"011. 盛最多水的容器"},{"content":" 题目链接：283. 移动零 知识回顾： 双指针常用套路 关键观察 原地操作 + 保持顺序 → 双指针 其实这个就是双指针的套路，维护指定索引 算法步骤 左指针 left：指向下一个应放置非零元素的位置（即已处理好的非零序列的右边界）。 右指针 right：遍历整个数组，寻找非零元素。 若 nums[right] != 0： 如果 left != right，则交换 nums[left] 与 nums[right]； left 向右移动一位。 复杂度分析 时间复杂度： $O(n)$ 只需一次遍历 空间复杂度：$O(1)$ 原地操作，仅使用常数个额外空间 1 2 3 4 5 6 7 8 9 10 11 class Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; left = 0 for right, num in enumerate(nums): if num and left!=right: nums[right],nums[left] = nums[left],nums[right] if nums[left] != 0: left += 1 优化 1 2 3 4 5 6 7 8 9 10 class Solution: def moveZeroes(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; left = 0 for right, num in enumerate(nums): if num: nums[right],nums[left] = nums[left],nums[right] left += 1 ","date":"2025-12-19T00:00:00Z","permalink":"https://example.com/p/283-move-zeroes/","title":"283. 移动零"},{"content":"快慢指针 滑动窗口 ","date":"2025-12-19T00:00:00Z","permalink":"https://example.com/p/%E5%8F%8C%E6%8C%87%E9%92%88%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/","title":"双指针常用套路"},{"content":" 题目链接：128. 最长连续序列 知识回顾： 哈希表 在 Python 中，set (集合)是基于哈希表实现的，支持 $O(1)$ 平均时间复杂度的成员检查（in 操作） 观察到：找数字连续的最长序列→找连续序列→找连续序列中的最大值/最小值 不妨来寻找序列的最小值 算法步骤 遍历列表 num 若 num - 1 存在于列表中，则 num 不是最小值 否则，num 为最小值，开始找最大值，并记录长度 更新长度 由于在 python 中，判断 num 是否在 nums 中的语句为 if num in nums 当 nums 为列表时，查找的时间复杂度为 $O(n)$ 因此，将 nums 转换为哈希表（元组） 复杂度分析 时间复杂度：$O(n)$ 虽然有嵌套循环，但每个元素最多被访问两次 一次在外层 for 循环，一次在 while 循环中作为连续序列的一部分 并不是每次 for 都会执行 while 因此整体仍是线性时间 空间复杂度：$O(n)$ 需要额外空间存储 set(nums) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def longestConsecutive(self, nums: List[int]) -\u0026gt; int: # 首先找到一个连续序列中最小的 # 然后不断 +1 并判断是否在序列中 nums = set(nums) max_len = 0 for num in nums: if num - 1 not in nums: # 找到某一序列的最小值 i = 1 num_ = num + 1 while num_ in nums: num_ = num_ + 1 i = i + 1 max_len = max(max_len, i) return max_len 1 2 3 4 5 6 7 8 9 10 11 12 # 简化 class Solution: def longestConsecutive(self, nums: List[int]) -\u0026gt; int: nums = set(nums) max_len = 0 for num in nums: if num - 1 not in nums: # 找到某一序列的最小值 num_ = num + 1 while num_ in nums: num_ = num_ + 1 max_len = max(max_len, num_ - num) return max_len ","date":"2025-12-18T00:00:00Z","permalink":"https://example.com/p/128-longest-consecutive-sequence/","title":"128. 最长连续序列"},{"content":" 未完持续 ","date":"2025-12-18T00:00:00Z","permalink":"https://example.com/p/set/","title":"元组"},{"content":" 题目链接：1. 两数之和 知识回顾：哈希表 暴力解法 使用两层 for 循环遍历所有两数组合 时间复杂度：$O (n^2)$ 空间复杂度：$O (1)$ 其中 $n$ 为数组长度 哈希表优化 核心思想：将问题 num1 + num2 = target 转化为 num2 = target - num1 若能快速判断 target - num1 是否已出现过，并获取其索引，则可一次遍历解决 在普通列表中查找元素需 $O(n)$，但哈希表支持平均 $O (1)$ 的查找 算法步骤： 初始化空哈希表 hash_map 遍历数组，对每个元素 num 及其索引 i： 若 target - num 已在哈希表中，返回 [hash_map[target - num], i] 否则，将 num: i 存入哈希表 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 1 2 3 4 5 6 7 8 class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: hash_map = {} for i, num in enumerate(nums): complement = target - num if complement in hash_map: return [hash_map[complement], i] hash_map[num] = i ","date":"2025-12-17T00:00:00Z","permalink":"https://example.com/p/001-two-sum/","title":"01. 两数之和"},{"content":" 题目连接： 49. 字母异位词分组 知识回顾： 哈希表 Python 中 defaultdict 的使用 关键观察：对字符串排序后，所有字母异位词会变成相同的字符串。 因此，我们可以将排序后的字符串作为哈希表的键，原始字符串作为值存入对应的列表中。 算法步骤： 初始化空哈希表 遍历字符串数组 将字符串进行排序 sorted_str 若 sorted_str 在哈希表中，则新增字母异位词 否侧，将 sorted_str: [srt] 存入哈希表 复杂度分析 时间复杂度：$O(nm\\log m)$ 其中 $n$ 为列表长度 $m$ 为字符串长度 长度为 $m$ 的字符串排序耗时 $m\\log m$ 空间复杂度： $O(nm)$ $n$ 为字符串个数，$m$ 为字符串平均长度 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def groupAnagrams(self, strs: List[str]) -\u0026gt; List[List[str]]: # 将字符串重新排序，作为字典的键 # 字典的值用于存储字符串 my_dict = {} for str_ in strs: sorted_str = \u0026#34;\u0026#34;.join(sorted(str_)) if sorted_str in my_dict: my_dict[sorted_str].append(str_) else: my_dict[sorted_str] = [str_] return list(my_dict.values()) 使用 defaultdict(list) 简化逻辑 在普通字典（dict）中，当你访问一个不存在的键时，会抛出 KeyError。因此，在向字典中追加值之前，必须先判断该键是否存在： 1 2 3 4 if key in my_dict: my_dict[key].append(value) else: my_dict[key] = [value] 而 collections.defaultdict 是 dict 的子类，它在访问不存在的键时，会自动调用传入的工厂函数（如 list）来生成默认值。 当你写 defaultdict(list) 时，意味着： “如果某个键不存在，就自动为它创建一个空列表 []。” 因此，你可以直接写： 1 hashmap[key].append(value) 即使 key 之前从未出现过，hashmap[key] 也会返回一个空列表，append 操作安全有效。 1 2 from collections import defaultdict hashmap = defaultdict(list) ","date":"2025-12-17T00:00:00Z","permalink":"https://example.com/p/049-group-anagrams/","title":"049. 字母异位词分组"},{"content":" 未完持续 ","date":"2025-12-17T00:00:00Z","permalink":"https://example.com/p/hash-table/","title":"哈希表"},{"content":"一、PINN 简介 Physics-Informed Neural Networks 1.1 什么是 PINN 背景 很多科学里的问题，没有太多数据可以学，但我们有物理规律 比如 海水怎么流（数据少，但物理规律明确） 心脏里的血流怎么走（不好测，但物理知道） 地震波怎样传播（难观察，但方程知道） 普通 AI 不懂这些规律，会乱猜 PINN 就能利用物理规律，少量数据也能算得非常准 用一句话来说，PINN 就是：让“神经网络”按照“物理定律”来学习的一种方法 这里给一个比喻 训练一个普通的 AI 模型，就像教一个小孩画画。这个孩子只知道照着例子画，你给什么他画什么（照猫画虎），没道理可讲（即神经网络输出的结果只与真实标签做损失，监督学习） 但是 PINN 不一样 给它一点点实际数据，它能学 最重要的是，它还“从小背过物理书”，知道 水怎么流 热怎么传 风怎么吹 东西怎么震动 光怎么折射 这些都叫 “物理方程” 所以它不是瞎学，它有“规矩”，有“脑子”，有“常识” 就像绘画高手，懂结构、光影、透视，所以会画的更好 1.2 PINN 与普通神经网络的区别 神经网络用来“猜”答案 比如猜温度、压力、水的速度…… 但是它的猜法必须满足“物理方程” 比如能量守恒、质量守恒、牛顿定律…… 就像告诉它：你不能乱猜，要合规矩！ 用“数据 + 物理”一起纠正它 它猜得不对，马上被纠正 物理方程也不让它瞎走 于是越猜越准 举例子 例子 1：屋子里温度怎么变？ 假设房间里有暖气，问 30 分钟后哪个角落最暖？ 普通神经网络： 要给它很多温度计数据，它才能学。 PINN： 给它少量数据 + 热传导定律，它自己能算出整个房间的温度分布。 例子 2：水从高处往低处流 PINN 知道“水往低处流”的规律，不需要测每个点的水速 例子 3：心脏里的血流 医院无法把心脏每个点都装传感器 但 PINN 用少量 MRI 数据 + 流体力学规律 就能推算整个心脏内部血流 二、PINN 的框架 PINN 模型通常由一个深度神经网络构成，其特点在于损失函数中加入了物理信息项，即所遵循的物理定律 PINN 主要分以下两个部分 神经网络结构 网络输入通常是问题域中的位置、时间等参数，输出是感兴趣物理量的估计值（例如速度、压力等） 定义损失函数 损失函数是模型训练中的关键部分，又包含以下两部分 数据损失项 这部分用来衡量网络预测输出与实际观测数据之间的差异，目的是使网络能够尽可能拟合数据 物理损失项 这部分是 PINN 独有的，它考量了网络预测结果是否满足物理定律 将网络预测的物理量代入相应的物理定律（通常是微分方程）中计算得到的残差构成这一部分损失函数，从而确保了物理一致性 三、PINN 的应用 这里以浅水方程为例：构建一个能够利用地形深度输入、并通过物理方程约束来预测浅水动力过程（如流速、水深演化）的 PINN 模型 基于地形的洪水模拟 浅水方程（Shallow Water Equations, SWE）二维形式如下（以保守型为例，假设地形平坦，无摩擦） 质量守恒、动量守恒 其中 $h(x,y,t)$：水深 $u,v$：水平速度 $g$：重力加速度 浅水方程的核心目标是描述 水深如何随时间变化：（质量守恒，Continuity） 水流速度如何随时间变化：（动量守恒，Momentum） 换句话说 浅水方程告诉我们：水有多深，以及它往哪里、以多快的速度流动。 由于忽略了垂向加速度并假设压力近似为静水压力，浅水方程比完整的 Navier–Stokes 方程更简单，但仍保留了大部分重要物理特征，非常适合大尺度水动力模拟 神经网络预测 $(h_θ​,u_θ​,v_θ​)$ 将其代入 PDE，构造残差 物理损失 最终损失 伪代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 伪代码概念演示 for batch in dataloader: img_obs, DEM, cond = batch # 遥感观测，地形等 t = sample_time_steps() x_t = q_sample(img_obs, t) # 扰动成噪声 (扩散训练常规) eps_pred = model(x_t, t, cond) # 去噪网络输出噪声估计 # 基本扩散损失 L_data = mse(eps_pred, true_eps) # decode to physical fields (e.g., h,u,v) from x_t or eps_pred h, u, v = decode_physical_field(x_t, eps_pred, DEM, cond) # compute physics residuals (using finite diff or differentiable solver) residual = shallow_water_residual(h, u, v, DEM) L_phy = mse(residual, 0) loss = L_data + lambda_phy * L_phy loss.backward() optimizer.step() 参考文献 PINN——加入物理约束的神经网络 - 知乎 物理信息神经网络（PINN）: 将物理知识融合到深度学习中 Physics Informed Neural Networks (PINNs) [Physics Informed Machine Learning] PINN核心技术揭秘：如何用神经网络求解偏微分方程？ ","date":"2025-12-01T00:00:00Z","permalink":"https://example.com/p/pinn-physics-informed-neural-networks/","title":"PINN——物理信息神经网络"}]